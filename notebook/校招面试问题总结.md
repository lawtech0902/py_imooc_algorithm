

## Python题目

### 1.介绍下Python

- 动态类型语言(运行期间确定数据类型，编译期间就确定数据类型的是Java和C这种)
- 强类型语言(Java 和 Python 是强制类型定义的。您有一个整数，如果不明确地进行转换 ，不能将把它当成一个字符串)
- 万物皆对象。字符串是对象，列表是对象，函数是对象，甚至模块也是对象！python对象源码：http://www.wklken.me/posts/2014/08/05/python-source-object.html
- 解释执行
- 主要还是代码简介优雅，第三方库多，有效支持快速开发

### 2.python上下文管理器

#### 原理

其实只要你的类定义了”__enter__()”和”__exit__()”方法，就可以使用Python的上下文管理器了。”__enter__()”方法会在with语句进入时被调用，其返回值会赋给as关键字后的变量；而”__exit__()”方法会在with语句块退出后自动被调用。

例子：

```python
class OpenFileDemo(object):
  def __init__(self, filename):
    self.filename = filename
   
  def __enter__(self):
    self.f = open(self.filename, 'a+')
    return self.f
  
  def __exit__(self, exc_type, exc_val, exc_tb):
    self.f.close()
    if exc_type != SyntaxError:
      return True
    return False   # Only raise exception when SyntaxError
```

#### contextlib模块

如果说with语句块在退出时会自动调用”__exit__()”方法的话，那用了”contextlib.closing()”的with语句块则在退出时会自动调用”close()”方法。看一下示例：

``` python
import contextlib
 
class Resource(object):
    def open(self):
        print 'Open Resource'
 
    def close(self):
        print 'Close Resource'
 
with contextlib.closing(Resource()) as r:
    r.open()
```

程序运行后，会打印出

```
Open Resource
Close Resource
```

说明Resource类创建的对象被赋给了as关键字后面的变量r，而with语句块退出时，自动调用了”r.close()”方法。

### 3.单例

####优点

1. 实例控制

单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。

2. 灵活性

因为类控制了实例化过程，所以类可以灵活更改实例化过程。

####缺点

1. 开销

虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。

2. 可能的开发混淆

使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。

#### 实现

#####1.最简单的module方式

``` python
# some module.py
class SingletonClass:
  pass

# 在别处我们想用这个实例都直接使用 module.single_instance 这个实例就好。
# 这是最简单也是最直观的一种方式,嗯，直接导入这个实例用，而不是导入class，简单粗暴
single_instance = SingletonClass()
```

#####2.装饰器实现

``` python
class BaseClass:
  pass


def singleton(class_):
  _instances = {}
  def get_instance(*args, **kwargs):
    if class_ not in instances:
      _instances[class_] = class_(*args, **kwargs)
    return _instances[class_]
  return get_instance

@singleton
class MyClass(BaseClass):
  pass
```

#####3.元类

``` python
class Singleton(type):
  _instances = {}
  def __call__(cls, *args, **kwargs):
    if cls not in cls._instances:
      cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
    return cls._instances[cls]
  
# py2
class MyClass(BaseClass):
  __metaclass__ = Singleton
  
# py3
class MyClass(BaseClass, metaclass = Singleton):
  pass
```

### 4.python面向对象和Mixin

- 面向过程：根据业务逻辑从上到下写垒代码
- 函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可
- 面向对象：对函数进行分类和封装，让开发“更快更好更强…”，设计思想就是抽象出Class，根据Class创建Instance。

https://blog.csdn.net/weixin_36586120/article/details/79201338

混入类在标准库中很多地方都出现过，通常都是用来像上面那样扩展某些类的功能。 它们也是多继承的一个主要用途。比如，当你编写网络代码时候， 你会经常使用 `socketserver` 模块中的 `ThreadingMixIn` 来给其他网络相关类增加多线程支持。 **主要实现类似多重继承的效果**

### 5.python代码性能分析工具

#### 1.time模块

####2.timeit模块

`python3.6 -m timeit -n 5 -r 5 -s "import module_name" "module_name.func(*args, **kwargs)"`

- -m: 指定要作为脚本运行的内置模块名称，这里就是 timeit 模块
- -n: 表示 timeit 要对执行的代码循环执行 n 次
- -r: 表示 timeit 会重复 r 次执行。 -n 与 -r 的表示的意思就是，timeit 模块首先会对要执行的代码循环执行 n 次，取 n 次的平均值作为一个结果，然后重复 r 次，这样就得到了 r 个结果，然后选出最好的结果进行返回
- -s: 表示导入要执行的代码所属的 module, 后面就是通过 module_name.func_name() 表示要测试执行的代码了

#### 3.cProfile模块

`python -m cProfile -s cumulative cp02/demo01.py`

-m 表示执行 cProfile 模块， -s cumulative 表示对每个函数累计花费时间进行排序，可以让我们很直观的看到哪一部分的代码执行的最慢。 其输出各项的含义如下：

- ncalls: 函数执行次数
- tottime: 累计耗时
- percall: 每次耗时
- cumtime: 包括子函数的执行时间
- percall 每次的执行时间
- filename:lineno(function): 文件名+代码行数+方法名

通过 cProfile 可以快速的定位出现性能瓶颈的函数，然后在针对函数进行进一步的分析。

#### 4.line_profiler

line_profiler 可以对函数进行逐行分析，是调查 Python 的 CPU 密集型问题最强大的工具。通常的使用步骤是先用 cProfile 进行函数分析， 然后在对有性能瓶颈的函数进行逐行分析。

### 6.python的 @staticmethod，@classmethod和@property

这些装饰器都是用来装饰类里面的方法的，首先，类的一般来说需要实例化后才能调用。但是使用了这前面两个装饰器，就可以不用实例化就可以直接调用类了。直接 类名.方法名() 来调用。这样有助于组织代码。

@staticmethod  不需要表示自身对象的self和自身类的cls参数，就和使用普通的函数一样。

@classmethod  不需要self参数，但是第一个cls参数需要表示自身类的cls参数。

简而言之，在类里有@staticmethod的，可以直接调用，没有加上改装饰器的方法就不能去调用。

@classmethod的话，在类里的所有方法都可以调用的。

那最后一个装饰器是什么意思呢。简而言之就是可以在调用的时候不用加()，表示类的属性

### 7.python引用变量顺序

python引用变量的顺序： 当前作用域局部变量->外层作用域变量->当前模块中的全局变量->python内置变量 

### 8.python元类

<http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python>

元编程依赖于python的一个叫做元类的概念。元类就是当你的某段代码在被执行的过程中，另外一段代码同时在被执行。维基百科上说的很好，在面向对象编程中，元类的实例还是类。

通过函数 `id()` 可以查看对象的ID标识。

通过 `type()` 可以查看对象的类型。

所有类的类型都是 type，也就是说所有的类都是由type 创建的。这个 type 就是元类，道生一，一生二，三生万物，元类就是 Python 中的造物主。（元类自己也是对象）。

![img](https://user-gold-cdn.xitu.io/2018/1/28/1613bf866b64d0e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

`type` 有一个作用是用于检查对象的类型，其实它还有另外一个作用就是作为元类动态地创建类（对象）。

```
>>> Person = type("Person", (), {"live":True})
>>> Person
<class '__main__.Person'>
复制代码
```

Person 就是一个类，它等价于：

```
>>> class Person:
...     live = True
...
>>> Person
<class '__main__.Person'>
复制代码
```

用元类 `type` 创建类的语法是：

```
type(类名,基类元组(可以为空), 属性字典)
```

### 9.python自省

自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance()，类似java、golang的反射reflect。

### 10.单下划线和双下划线

`__foo__`:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如`__init__()`,`__del__()`,`__call__()`这些特殊方法

`_foo`:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；

`__foo`:这个有真正的意义:解析器用`_classname__foo`来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.

### 11.迭代器和生成器

这个是stackoverflow里python排名第一的问题,值得一看: <http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python>

这是中文版: <http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html>

这里有个关于生成器的创建问题面试官有考： 问： 将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器

```
>>> L = [x*x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x*x for x in range(10))
>>> g
<generator object <genexpr> at 0x0000028F8B774200>
```

通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—>generator

### 12. 面向切面编程AOP和装饰器

装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，**装饰器的作用就是为已经存在的对象添加额外的功能。**

### 13.duck typing

“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。

比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。

又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.

鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。

### 14.新式类和旧式类

新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),<Python核心编程>里讲的也很多.

> 一个旧式类的深度优先的例子

```python
class A():
    def foo1(self):
        print "A"
class B(A):
    def foo2(self):
        pass
class C(A):
    def foo1(self):
        print "C"
class D(B, C):
    pass

d = D()
d.foo1()

# A
```

### 15.`__new__`和`__init__`的区别

这个`__new__`确实很少见到,先做了解吧.

1. `__new__`是一个静态方法,而`__init__`是一个实例方法.
2. `__new__`方法会返回一个创建的实例,而`__init__`什么都不返回.
3. 只有在`__new__`返回一个cls的实例时后面的`__init__`才能被调用.
4. 当创建一个新实例时调用`__new__`,初始化一个实例时用`__init__`.

ps: `__metaclass__`是创建类时起作用.所以我们可以分别使用`__metaclass__`,`__new__`和`__init__`来分别在类创建,实例创建和实例初始化的时候做一些小手脚.

### 16.python赋值、浅拷贝、深拷贝区别

``` python
>>> import copy
>>> a = [[1, 2],[5, 6], [8, 9]]
>>> b = copy.copy(a)              # 浅拷贝得到b
>>> c = copy.deepcopy(a)          # 深拷贝得到c
>>> print(id(a), id(b))           # a 和 b 不同
139832578518984 139832578335520
>>> for x, y in zip(a, b):        # a 和 b 的子对象相同
...     print(id(x), id(y))
... 
139832578622816 139832578622816
139832578622672 139832578622672
139832578623104 139832578623104
>>> print(id(a), id(c))           # a 和 c 不同
139832578518984 139832578622456
>>> for x, y in zip(a, c):        # a 和 c 的子对象也不同
...     print(id(x), id(y))
... 
139832578622816 139832578621520
139832578622672 139832578518912
139832578623104 139832578623392
```

1、赋值：简单地拷贝对象的引用，两个对象的id相同。
2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。
3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。

浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。

### 17.python gc

**看看源码：http://www.wklken.me/posts/2015/09/29/python-source-gc.html**

Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。

- 引用计数

PyObject是每个对象必有的内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用时，它的`ob_refcnt`就会增加，当引用它的对象被删除，它的`ob_refcnt`就会减少.引用计数为0时，该对象生命就结束了。

优点:

1. 简单
2. 实时性

缺点:

1. 维护引用计数消耗资源
2. 循环引用

- 标记-清除机制

基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

- 分代回收：以空间换时间

分代回收的整体思想是：将系统中的所有内存块根据其存活的时间划分为不同的集合, 每个集合就成为一个"代", 垃圾收集的频率随着"代"的存活时间的增大而减小(活得越长的对象, 就越不可能是垃圾, 就应该减少去收集的频率)

Python中, 引入了分代收集, 总共三个"代". Python 中, 一个代就是一个链表, 所有属于同一"代"的内存块都链接在同一个链表中

### 18.python设计模式实现

https://python-web-guide.readthedocs.io/zh/latest/design/design.html

### 19.python可迭代对象，迭代器，生成器的区别

https://blog.csdn.net/jinixin/article/details/72232604

##操作系统，linux，Python并发

https://github.com/CyC2018/CS-Notes/blob/b6156c4247f05d29a65564f0e337545fde70fea1/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md

### 1.进程、线程区别

#### 进程

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

#### 线程线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

#### 区别

（一）拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

（二）调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。

（三）系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

（四）通信方面

进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。

### 2.进程同步和进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

#### 进程同步

- 临界区：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
- 同步、互斥：同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。
- 信号量：信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。**down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；**up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。
- 管程：管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

#### 进程通信

- 管道：管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。管道只支持半双工通信（单向交替传输）；只能在父子进程中使用。
- 命名管道（FIFO）：去除了管道只能在父子进程中使用的限制。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。
- 消息队列：相比于 FIFO，消息队列具有以下优点：
  - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
  - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
  - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
- 信号量：一个计数器，用于为多个进程提供对共享数据对象的访问。
- 共享存储：允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。需要使用信号量来同步访问。多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。
- 套接字：可用于不同机器间的进程通信。

### 3.线程安全

线程安全是在多线程的环境下，线程安全能够保证多个线程同时执行时程序依旧运行正确，而且要保证对于共享的数据，可以由多个线程存取，但是同一时刻只能有一个线程进行存取。

**多线程环境下解决资源竞争问题的办法是加锁来保证存取操作的唯一性。**

通常加锁也有2种不同的粒度的锁： 

- fine-grained(细粒度)，程序员需要自行加/解锁来保证线程安全 
- coarse-grained(粗粒度)，语言层面本身维护着一个全局的锁机制用来保证线程安全 

前一种方式比较典型的是 Java, Jython 等, 后一种方式比较典型的是 CPython (即Python)。

#### GIL

##### 是什么

GIL全称是Global Interpreter Lock，即全局解释锁，每个python解释器都有一个这样的全局锁，在解释器解释执行任何的python代码都要先获得这个锁。所以同一时间只有一个线程持有这个锁在运行，其他的线程都在等待这个锁。所以即使两个线程在执行死循环，但实际上每次只有一个线程在运行。

##### 为什么有GIL

python是解释性语言，是在python解释器上执行的，但是python解释器本身却不是线程安全的，如果没有GIL，那么在多线程中一些简单的操作都会出现问题，在可见变量我们可以自行加锁，而还有很多后台不可见的变量就需要GIL来控制了，比如为了进行垃圾回收而维护的引用计数，如果没有GIL，有可能出现由于线程切换导致的对同一个对象释放两次的情况。所以有了Lock还是需要GIL的。如果将GIL抛弃，所有的地方都用Lock也可以啊，这样就可以支持多线程并发了，曾有过官方实验发现这样的做法是得不偿失的，单线程的执行效率减慢了将近两倍，而且这样的做法却复杂了N倍，本来一个全局锁就可以解决的问题却花了N多个细微的锁来解决。所以这样是不值得的，何况python还有别的方式来实现并发。

##### 有了GIL还要Lock吗

线程的同步和互斥解决的是线程间数据的访问正确性问题，而GIL是实现当前Python解释器下只有一个线程在执行。两个是不同的概念。

### 4.阻塞、非阻塞、同步、异步

#### 同步与异步

同步和异步关注的是**消息通信机制 (synchronous communication/ asynchronous communication)**。

所谓同步，就是在**发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了**。
换句话说，就是由调用者主动等待这个调用的结果。

而异步则是相反，**调用在发出之后，这个调用就直接返回了，所以没有返回结果**。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

#### 阻塞与非阻塞

阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**。

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

### 5.select，poll，epoll

多路复用属于同步I/O模型，主旨是同时监听多个FD，一旦有事件发生，发送至相应的处理器处理以提高性能。

select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

基本上select有3个缺点:

1. 连接数受限
2. 查找配对速度慢
3. 数据由内核拷贝到用户态

poll改善了第一个缺点

epoll改了三个缺点

#### 区别

- 支持一个进程所能打开的最大连接数
  - select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，linux上为1024
  - poll：没有最大连接数的限制，原因是它是基于链表来存储的
  - epoll：连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接
- FD剧增后带来的IO效率问题
  - select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
  - poll：同上
  - epoll：因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。
- 消息传递方式
  - select：内核需要将消息传递到用户空间，都需要内核拷贝动作
  - poll：同上
  - epoll：epoll通过内核和用户空间共享一块内存来实现的

#### 总结

综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。

1. 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2. select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善

#### 应用场景

- 客户端要处理多个socket
- 客户端同时处理连接和用户输入，比如聊天室
- TCP服务器要同时处理监听socket和连接socket
- 服务器同时处理TCP和UDP
- 服务器要监听多个端口

#### 举例

- IO框架libevent
- 基于libevent和协程的python网络框架gevent
- python的高性能web框架tornado
- redis
- nginx, apache

####select 应用场景

select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。

select 可移植性更好，几乎被所有主流平台所支持。

####poll 应用场景

poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。

####epoll 应用场景

只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。

需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。

需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。

### 6. 僵尸进程孤儿进程

#### 为什么会有僵尸进程、孤儿进程

我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

- 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
- 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

#### 僵尸进程危害

占用系统进程表，而且进程表中的退出状态以及其它一些进程信息也是存储在内存中的。

#### 找出并杀掉僵尸进程

`ps aux | grep Z`会列出进程表中所有僵尸进程的详细内容。

正常情况下我们可以用 `SIGKILL` 信号来杀死进程，但是僵尸进程已经死了， 你不能杀死已经死掉的东西。

```shell
kill -s SIGCHLD pid
```

将这里的 pid 替换成父进程的进程 id，这样父进程就会删除所有以及完成并死掉的子进程了。

或者fork两次也可以杀掉。

### 7.死锁

#### 四个必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

#### 处理死锁的方法

- 鸵鸟策略：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

  大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

- 死锁检测与死锁恢复

- 死锁预防：破坏四个必要条件之一

- 死锁避免：①安全状态②银行家算法

### 8.页面置换算法

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

- 最佳（Optimal）
- 最近最久未使用（LRU）
- 最近未使用（NRU）
- 先进先出（FIFO）
- 第二次机会算法
- 时钟（Clock）

### 9.磁盘调度算法

- 先来先服务（FCFS，First Come First Served）:

  按照磁盘请求的顺序进行调度。

  优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

- 最短寻道时间优先（SSTF, Shortest Seek Time First）：优先调度与当前磁头所在磁道距离最近的磁道。

- 电梯算法（SCAN）：

  电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

  因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

##数据库（MySQL,Redis）

### 1.Redis速度快的原因

1完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

### 2.Redis为什么是单线程

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善。

### 3.NoSQL和SQL

https://juejin.im/post/5b7e6fd251882542aa1b35f9

### 4.Redis持久化

RDB（Redis DataBase）和AOF（Append Only File）

RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。

AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。

重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。

### 5.InnoDB, MyISAM比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

其他特点：

MySQL默认InnoDB，实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### 6.聚簇索引和非聚簇索引区别

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

https://blog.csdn.net/u010727189/article/details/79399384

### 7.分库分表如何部署上线

https://www.itcodemonkey.com/article/8796.html

### 8.数据库优化

https://www.itcodemonkey.com/article/8216.html

### 9.为什么MyISAM比InnoDB的查询要快

**INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多:**
1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少；
2）innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快
3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护MVCC

注释：

InnoDB：通过为每一行记录添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLEREAD时这种策略是如何应用到特定的操作的：

　　SELECT InnoDB必须每行数据来保证它符合两个条件：

　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。

　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除

##Python web

### 1.MTV,MVC,MVVM区别

#### MVC

Model（数据模型），View（视图），Contorller（控制器）

MVC的特点是通信单向的：

1. 浏览器发送请求
2. Contorller和Model交互获取数据
3. Contorller调用View
4. View渲染数据返回

#### MTV

Model（数据模型），Template（模板），View处理业务逻辑

MVC中的View的目的是「呈现哪一个数据」，而MTV的View的目的是「数据如何呈现」

Flask这种微框架就不是一个MVC模式的，因为它没有提供Model，除非集成了SQLAlchemy之类的ORM进来。

#### MVVM

MVVM（Model View ViewModel）是一种基于前端开发的架构模式，它的核心是提供对View和ViewModel的双向绑定，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，View的变动，自动反映在ViewModel上，反之亦然，这样就保证视图和数据的一致性。

ViewModel是Model和View之间的桥梁，它的设计原则是：

- 为Model和View提供适配
- 如果有需要转换的过程，尽可能在ViewModel中做，保持Model的纯洁，View的清晰。

### 2.前后端分离好处坏处

开发效率、后端专注服务的提供、前端专注服务的调用，很容易的解决了多客户端的问题，SEO可能是个问题。

### 3.web负载均衡

https://blog.csdn.net/ll641058431/article/details/77888716

### 4.负载均衡算法

1. 随机算法
2. 轮询及加权轮询
3. 最小连接及加权最小连接
4. 哈希算法
5. IP地址散列
6. URL散列

https://segmentfault.com/a/1190000004492447#articleHeader8

### 5.正向代理和反向代理区别

一句话：正向代理为客户端服务，如vpn翻墙服务器，服务端不需要再做什么；反向代理为服务端服务，如负载均衡减轻服务端负担，客户端不需要再做什么。

复杂点：

​	从用途上来区分：

- 正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率
- 反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能

  从安全性来讲：

- 正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务
- 反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器

### 6.Django权限控制

https://www.jianshu.com/p/01126437e8a4

### 7.Flask权限控制

https://cloud.tencent.com/developer/article/1115801

### 8.Django和Flask区别选择

https://www.zhihu.com/question/41564604

### 9.REST面试题

http://forevernull.com/2017/09/28/top-20-rest-api%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94%EF%BC%88%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E7%89%88%E6%9C%AC%EF%BC%89%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91/

### 10.WSGI、UWSGI

https://www.jianshu.com/p/679dee0a4193

### 11.Django migrate原理

https://yiyibooks.cn/xx/django_182/topics/migrations.html

### 12.Django manage.py源码解析

https://www.jianshu.com/p/3319598f879b

##爬虫相关

### 1.DFS和BFS

一般来说用DFS解决的问题都可以用BFS来解决。
DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。
总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易"控制")，BFS通过控制队列可以很好解决"爆队列"风险。
它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。

### 2.Scrapy架构

https://segmentfault.com/a/1190000014333162

## Docker

https://github.com/CyC2018/CS-Notes/blob/b6156c4247f05d29a65564f0e337545fde70fea1/notes/Docker.md

## Git问题

https://juejin.im/post/59ecb3976fb9a0452724bde0

## 网络



##HTTP

https://github.com/CyC2018/CS-Notes/blob/b6156c4247f05d29a65564f0e337545fde70fea1/notes/HTTP.md

### 1.HTTPS通信过程

![img](http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97-3-5.jpg)

## 分布式理论

https://github.com/CyC2018/CS-Notes/blob/b6156c4247f05d29a65564f0e337545fde70fea1/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md

## DPDK

https://www.jianshu.com/p/0ff8cb4deaef

 



